## Decorator Pattern

<br>


### 데코레이터 패턴

- 기존 코드를 변경하지 않으면서도 부가기능을 추가해줄 수 있는 패턴
- 부가기능을 동적으로 추가한다

> 데코레이터 패턴이란 주어진 상황 및 용도에 맞게 어떤 객체에 책임을 덧붙이는 패턴으로 기능확장이 필요할 때 `상속` 대신 사용할수 있는 기능

기존 코드로부터 다양한 기능을 확장하고자 할 때 상속을 활용하면 유연하지 못하다. 

`(이펙티브 자바: 상속보다는 컴포지션을 활용하라 참고하기)`

이런 부분을 해소하면서도 기존부분으로부터 다양한 기능을 덧붙일 수 있게 해준다.

데코레이터(래퍼) 통해 직접적인 상속구조를 없애고 한 번 감싸줌


<br>



### 장점

- 새로운 클래스를 만들지 않고도 새로운 기능을 `조합`해낼 수 가 있다.

> 데코레이터들의 구현체에서는 자신이 하고자하는 일만 처리하게 끔 할 수 있다. 기존 직접적 상속구조에서는 휘핑크림 + 샷으로 조합된 새로운 기능을 만들어야 했다. 

- 컴파일 타임이 아니라 런타임 시에 동적으로 기능을 변경할 수 있다.

> 기존 직접상속구조에서는 각기 인스턴스들의 동작을 활용한 새로운 조합에 대한 코드를 미리 정의해야 했으나 데코레이터 패턴을 활용하면 동적으로 존재하는 인스턴스들의 조합을 만들어낼 수 있다.

<br>

**전**

![image](https://user-images.githubusercontent.com/76927397/187069349-a976b751-5d67-4d43-9e5b-e3dedd24e998.png)


**후**

![image](https://user-images.githubusercontent.com/76927397/187069329-09d063ab-7ef5-4eff-a0e4-dacd8702769b.png)


카페에서 손님의 요구에 알바생의 침이 가능해진다고 생각해보자

손님은 샷 + 휘핑크림 + 알바생의 침의 조합을 요구할 수 있기 때문에 단순 상속구조에서는 조합의 수만큼 하위 클래스가 늘어나야만 한다.

데코레이터 패턴에서는 데코레이터 구현체로 알바생의 침 클래스만 추가하면 모든 조합을 커버할 수 있게 된다.

CoffeeService 라는 타입을 Decorator 컴포지션(멤버)으로 하고 그 타입으로 구현하고 이를 바탕으로 하위클래스들을 작성하여

클라이언트에서는 CoffeeService 를 통해 모든 하위 데코레이터들을 커버할 수 있게 된다.


```java

```

